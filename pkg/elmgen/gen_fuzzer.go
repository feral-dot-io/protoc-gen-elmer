package elmgen

import (
	"fmt"
	"os"
	"os/exec"
	"strconv"

	"google.golang.org/protobuf/compiler/protogen"
)

const DefaultFuzz = 0

func runElmTest(projDir, globs string, fuzz int) (err error) {
	// Restore pwd
	var pwd string
	if pwd, err = os.Getwd(); err != nil {
		return
	}
	defer func() {
		err2 := os.Chdir(pwd)
		// Don't ovewrite our error
		if err2 != nil && err == nil {
			err = err2
		}
	}()
	// Change pwd to root of Elm project
	if err = os.Chdir(projDir); err != nil {
		return
	}

	cmd := exec.Command("elm-test")
	if fuzz > 0 {
		cmd.Args = append(cmd.Args, "--fuzz", strconv.Itoa(fuzz))
	}
	if globs != "" {
		cmd.Args = append(cmd.Args, globs)
	}
	cmd.Stderr = os.Stderr
	cmd.Stdout = os.Stdout
	err = cmd.Run()
	return
}

func GenerateFuzzTests(m *Module, g *protogen.GeneratedFile) {
	gFP := func(formatter string, args ...interface{}) {
		g.P(fmt.Sprintf(formatter, args...))
	}

	var ids []CodecIDs
	for _, r := range m.Records {
		ids = append(ids, r.CodecIDs)
	}
	for _, u := range m.Unions {
		ids = append(ids, u.CodecIDs)
	}

	g.P("-- Generated by protoc-gen-elmgen. DO NOT EDIT!")
	g.P("module ", m.Name, "Tests exposing (")
	for i, c := range ids {
		prefix := "    "
		if i != 0 {
			prefix += ", "
		}
		gFP("%stest%s", prefix, c.ID)
	}
	if len(ids) == 0 {
		g.P("..")
	}
	g.P(")")

	g.P("import ", m.Name)
	if m.Imports.Bytes {
		g.P("import Bytes exposing (Bytes)")
		g.P("import Bytes.Encode as BE")
	}
	g.P("import Expect")
	g.P("import Fuzz exposing (Fuzzer)")
	g.P("import Protobuf.Decode as PD")
	g.P("import Protobuf.Encode as PE")
	g.P("import Test exposing (Test, fuzz, test)")

	// Helpers
	if m.Fuzzers.Int32 || m.Fuzzers.Float32 || len(m.Unions) > 0 {
		g.P("fuzzInt32 : Fuzzer Int")
		g.P("fuzzInt32 =")
		g.P("    Fuzz.intRange -2147483648 2147483647")
	}
	if m.Fuzzers.Uint32 {
		g.P("fuzzUint32 : Fuzzer Int")
		g.P("fuzzUint32 =")
		g.P("    Fuzz.intRange 0 4294967295")
	}
	if m.Fuzzers.Float32 {
		// Avoid trying to robusly map float64 (JS) -> float32
		// Only tests exponent (float32 has 8 bits)
		g.P("fuzzFloat32 : Fuzzer Float")
		g.P("fuzzFloat32 =")
		g.P("    Fuzz.map (\\i -> 2 ^ toFloat i) fuzzInt32")
	}
	if m.Imports.Bytes {
		g.P("fuzzBytes : Fuzzer Bytes")
		g.P("fuzzBytes =")
		g.P("    Fuzz.intRange 0 255")
		g.P("        |> Fuzz.map BE.unsignedInt8")
		g.P("        |> Fuzz.list")
		g.P("        |> Fuzz.map (BE.sequence >> BE.encode)")
	}

	// Union fuzzers
	for _, u := range m.Unions {
		gFP("%s : Fuzzer Codec.%s", u.FuzzerID, u.ID)
		gFP("%s =", u.FuzzerID)
		gFP("    Fuzz.oneOf")
		d := u.DefaultVariant
		gFP("        [ Fuzz.map Codec.%s fuzzInt32", d.ID)
		for _, v := range u.Variants {
			gFP("        , Fuzz.constant Codec.%s", v.ID)
		}
		gFP("        ]")
	}

	// Record fuzzers
	for _, r := range m.Records {
		gFP("%s : Fuzzer Codec.%s", r.FuzzerID, r.ID)
		gFP("%s =", r.FuzzerID)
		/* TODO
		gFP("    let")
		for _, o := range r.Oneofs {
			g.P("        ", o.FuzzerID, " =")
			for j, v := range o.Variants {
			}
			g.P("                ]")
		}
		gFP("    in")
		*/
		gFP("    Fuzz.map Codec.%s", r.ID)
		for i, f := range r.Fields {
			prefix := "        "
			if i != 0 {
				prefix += "|> Fuzz.andMap"
			}
			var wrapper string
			if f.IsOneof {
				wrapper = "Fuzz.maybe"
			}
			gFP("%s (%s %s)", prefix, wrapper, f.Fuzzer)
		}
	}

	// Test cases
	for _, c := range ids {
		g.P("test", c.ID, " : Test")
		g.P("test", c.ID, " =")
		g.P("    let")
		// TODO move `run` to top-level
		g.P("        run data =")
		g.P("            PE.encode (Codec.", c.EncodeID, " data)")
		g.P("                |> PD.decode Codec.", c.DecodeID)
		g.P("                |> Expect.equal (Just data)")
		g.P("    in")
		g.P(`    Test.describe "encode then decode `, c.ID, `"`)
		g.P(`        [ test "empty" (\_ -> run Codec.empty`, c.ID, `)`)
		g.P(`        , fuzz `, c.FuzzerID, ` "fuzzer" run`)
		g.P("        ]")
	}
}
