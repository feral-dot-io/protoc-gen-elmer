package elmgen

import (
	"fmt"
	"os"
	"os/exec"
	"strconv"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
)

func runElmTest(projDir, globs string, fuzz int) (err error) {
	// Restore pwd
	var pwd string
	if pwd, err = os.Getwd(); err != nil {
		return
	}
	defer func() {
		err2 := os.Chdir(pwd)
		// Don't ovewrite our error
		if err2 != nil && err == nil {
			err = err2
		}
	}()
	// Change pwd to root of Elm project
	if err = os.Chdir(projDir); err != nil {
		return
	}

	cmd := exec.Command("elm-test")
	if fuzz > 0 {
		cmd.Args = append(cmd.Args, "--fuzz", strconv.Itoa(fuzz))
	}
	if globs != "" {
		cmd.Args = append(cmd.Args, globs)
	}
	cmd.Stderr = os.Stderr
	cmd.Stdout = os.Stdout
	err = cmd.Run()
	return
}

func GenerateFuzzTests(m *Module, g *protogen.GeneratedFile) {
	gFP := func(formatter string, args ...interface{}) {
		g.P(fmt.Sprintf(formatter, args...))
	}

	var ids []CodecIDs
	for _, r := range m.Records {
		ids = append(ids, r.CodecIDs)
	}
	for _, u := range m.Unions {
		ids = append(ids, u.CodecIDs)
	}

	g.P("-- Generated by protoc-gen-elmgen. DO NOT EDIT!")
	g.P("module ", m.Name, "Tests exposing (..)")

	g.P("import ", m.Name)
	if m.Imports.Bytes {
		g.P("import Bytes exposing (Bytes)")
		g.P("import Bytes.Encode as BE")
	}
	if m.Imports.Dict {
		g.P("import Dict")
	}
	g.P("import Expect")
	g.P("import Fuzz exposing (Fuzzer)")
	g.P("import Protobuf.Decode as PD")
	g.P("import Protobuf.Encode as PE")
	g.P("import Test exposing (Test, fuzz, test)")

	// Helpers
	if m.Fuzzers.Int32 || m.Fuzzers.Float32 || len(m.Unions) > 0 {
		g.P("fuzzInt32 : Fuzzer Int")
		g.P("fuzzInt32 =")
		g.P("    Fuzz.intRange -2147483648 2147483647")
	}
	if m.Fuzzers.Uint32 {
		g.P("fuzzUint32 : Fuzzer Int")
		g.P("fuzzUint32 =")
		g.P("    Fuzz.intRange 0 4294967295")
	}
	if m.Fuzzers.Float32 {
		// Avoid trying to robusly map float64 (JS) -> float32
		// Only tests exponent (float32 has 8 bits)
		g.P("fuzzFloat32 : Fuzzer Float")
		g.P("fuzzFloat32 =")
		g.P("    Fuzz.map (\\i -> 2 ^ toFloat i) fuzzInt32")
	}
	if m.Imports.Bytes {
		g.P("fuzzBytes : Fuzzer Bytes")
		g.P("fuzzBytes =")
		g.P("    Fuzz.intRange 0 255")
		g.P("        |> Fuzz.map BE.unsignedInt8")
		g.P("        |> Fuzz.list")
		g.P("        |> Fuzz.map (BE.sequence >> BE.encode)")
	}

	// Union fuzzers
	for _, u := range m.Unions {
		gFP("%s : Fuzzer Codec.%s", u.FuzzerID, u.ID)
		gFP("%s =", u.FuzzerID)
		gFP("    Fuzz.oneOf")
		d := u.DefaultVariant
		gFP("        [ Fuzz.map Codec.%s fuzzInt32", d.ID)
		for _, v := range u.Variants {
			gFP("        , Fuzz.constant Codec.%s", v.ID)
		}
		gFP("        ]")
	}

	// Record fuzzers
	for _, r := range m.Records {
		gFP("%s : Fuzzer Codec.%s", r.FuzzerID, r.ID)
		gFP("%s =", r.FuzzerID)
		if len(r.Oneofs) > 0 {
			gFP("    let")
			for _, o := range r.Oneofs {
				gFP("        %s =", o.FuzzerID)
				gFP("            Fuzz.oneOf")
				for j, v := range o.Variants {
					prefix := "                "
					if j == 0 {
						prefix += "["
					} else {
						prefix += ","
					}
					if o.IsSynthetic { // Optional field
						gFP("%s %s", prefix, v.Field.Fuzzer)
					} else {
						gFP("%s Fuzz.map Codec.%s %s",
							prefix, v.ID, v.Field.Fuzzer)
					}
				}
				g.P("                ]")
			}
			gFP("    in")
		}

		if len(r.Fields) == 0 {
			gFP("    Fuzz.constant Codec.%s", r.ID)
		} else {
			gFP("    Fuzz.map Codec.%s", r.ID)
		}
		for i, f := range r.Fields {
			prefix := "        "
			if i != 0 {
				prefix += "|> Fuzz.andMap "
			}
			if f.IsOneof {
				gFP("%s(Fuzz.maybe %s)", prefix, f.Fuzzer)
			} else if f.IsMap {
				gFP("%s(Fuzz.map Dict.fromList", prefix)
				gFP("%s    (Fuzz.list (Fuzz.tuple (%s, %s))))",
					prefix, f.Key.Fuzzer, f.Fuzzer)
			} else if f.Cardinality == protoreflect.Repeated {
				gFP("%s(Fuzz.list %s)", prefix, f.Fuzzer)
			} else { // No special treatment
				gFP("%s%s", prefix, f.Fuzzer)
			}
		}
	}

	// Test cases
	for _, c := range ids {
		g.P("test", c.ID, " : Test")
		g.P("test", c.ID, " =")
		g.P("    let")
		// TODO move `run` to top-level
		g.P("        run data =")
		g.P("            PE.encode (Codec.", c.EncodeID, " data)")
		g.P("                |> PD.decode Codec.", c.DecodeID)
		g.P("                |> Expect.equal (Just data)")
		g.P("    in")
		g.P(`    Test.describe "encode then decode `, c.ID, `"`)
		g.P(`        [ test "empty" (\_ -> run Codec.empty`, c.ID, `)`)
		g.P(`        , fuzz `, c.FuzzerID, ` "fuzzer" run`)
		g.P("        ]")
	}
}
