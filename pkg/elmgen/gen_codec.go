package elmgen

import (
	"bytes"
	"fmt"
	"io"
	"os"
	"os/exec"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
)

func FormatFile(plugin *protogen.Plugin, path string, file *protogen.GeneratedFile) *protogen.GeneratedFile {
	// Fetch unformatted content
	content, err := file.Content()
	plugin.Error(err)
	unformatted := bytes.NewBuffer(content)
	file.Skip()
	// Run through elm-format
	formatted := plugin.NewGeneratedFile(path, "")
	err = runElmFormat(unformatted, formatted)
	plugin.Error(err)
	return formatted
}

func runElmFormat(in io.Reader, out io.Writer) error {
	cmd := exec.Command("elm-format", "--yes", "--stdin")
	cmd.Stdin = in
	cmd.Stderr = os.Stderr
	cmd.Stdout = out
	return cmd.Run()
}

func GenerateCodec(m *Module, g *protogen.GeneratedFile) {
	gFP := func(formatter string, args ...interface{}) {
		g.P(fmt.Sprintf(formatter, args...))
	}
	g.P("-- Generated by protoc-gen-elmgen. DO NOT EDIT!")
	g.P("module ", m.Name, " exposing (..)")

	g.P("-- This module is broken down into: records (messages), unions (enums), oneofs, empty constructors (zero values), decoders, and encoders")
	var recordIDs, unionIDs, oneofIDs []string
	for _, r := range m.Records {
		recordIDs = append(recordIDs, string(r.ID))
	}
	for _, u := range m.Unions {
		unionIDs = append(unionIDs, string(u.ID))
	}
	for _, o := range m.Oneofs {
		if !o.IsSynthetic {
			oneofIDs = append(oneofIDs, string(o.ID))
		}
	}
	idsToStr := func(ids []string) string {
		if len(ids) == 0 {
			return "(none)"
		}
		return strings.Join(ids, " ")
	}
	g.P("-- Records: ", idsToStr(recordIDs))
	g.P("-- Unions: ", idsToStr(unionIDs))
	g.P("-- Oneofs: ", idsToStr(oneofIDs))

	g.P("import Protobuf.Decode as PD")
	g.P("import Protobuf.Encode as PE")
	if m.Imports.Bytes {
		g.P("import Bytes exposing (Bytes)")
		g.P("import Bytes.Encode as BE")
	}
	if m.Imports.Dict {
		g.P("import Dict exposing (Dict)")
	}

	// Records
	for _, r := range m.Records {
		g.P("type alias ", r.ID, " =")
		g.P("    {")
		for i, f := range r.Fields {
			prefix := ","
			if i == 0 {
				prefix = ""
			}
			g.P("    ", prefix, " ", f.Label, " : ", f.Type)
		}
		g.P("    }")
	}

	// Unions
	for _, u := range m.Unions {
		g.P("type ", u.ID)
		g.P("    = ", u.DefaultVariant.ID, " Int")
		for _, v := range u.Variants {
			g.P("    | ", v.ID)
		}
		for _, a := range u.Aliases {
			g.P(a.Alias, " : ", u.ID)
			g.P(a.Alias, " = ", a.ID)
		}
	}

	// Oneofs (nested unions)
	for _, o := range m.Oneofs {
		// Skip optional
		if o.IsSynthetic {
			continue
		}
		g.P("type ", o.ID)
		for i, v := range o.Variants {
			prefix := "|"
			if i == 0 {
				prefix = "="
			}
			g.P("    ", prefix, " ", v.ID, " ", v.Field.Type)
		}
	}

	// Zero records
	for _, r := range m.Records {
		g.P(r.ZeroID, " : ", r.ID)
		g.P(r.ZeroID, " =")
		zeros := []interface{}{"    ", r.ID.String()}
		for _, f := range r.Fields {
			zero := f.Zero
			if f.IsMap {
				zero = "Dict.empty"
			}
			zeros = append(zeros, " ", zero)
		}
		g.P(zeros...)
	}

	// Zero unions
	for _, u := range m.Unions {
		g.P(u.ZeroID, " : ", u.ID)
		g.P(u.ZeroID, " =")
		g.P("    ", u.DefaultVariant.ID, " 0")
	}

	// Record decoders
	for _, r := range m.Records {
		g.P(r.DecodeID, " : PD.Decoder ", r.ID)
		g.P(r.DecodeID, " =")
		// Build oneof decoders inline since they're unique to the message
		// Ideally they'd be inline here (and in the decoder + fuzzer)
		if len(r.Oneofs) > 0 {
			g.P("    let")
			for _, o := range r.Oneofs {
				gFP("        %s =", o.DecodeID)
				g.P("            [")
				for j, v := range o.Variants {
					prefix := "            "
					if j != 0 {
						prefix += ","
					}
					if o.IsSynthetic { // Only field, skip map
						gFP("%s( %d, %s )",
							prefix, v.Field.WireNumber, v.Field.Decoder)
					} else {
						gFP("%s( %d, PD.map %s %s )",
							prefix, v.Field.WireNumber, v.ID, v.Field.Decoder)
					}
				}
				g.P("                ]")
			}
			g.P("    in")
		}
		g.P("    PD.message ", r.ZeroID)
		g.P("        [")
		for i, f := range r.Fields {
			prefix := "            "
			if i != 0 {
				prefix += ","
			}
			getter := "(\\v m -> { m | %s = v })"
			// Pick a FieldDecoder
			if f.IsOneof {
				gFP("%s PD.oneOf %s "+getter, prefix, f.Decoder, f.Label)
			} else if f.IsMap {
				gFP("%s PD.mapped %d ( %s , %s ) %s %s .%s "+getter,
					prefix, f.WireNumber,
					f.Key.Zero, f.Zero, f.Key.Decoder, f.Decoder,
					f.Label, f.Label)
			} else {
				switch f.Cardinality {
				default:
					fallthrough
				case protoreflect.Optional:
					gFP("%s PD.optional %d %s "+getter,
						prefix, f.WireNumber, f.Decoder, f.Label)

				case protoreflect.Required:
					gFP("%s PD.required %d %s "+getter,
						prefix, f.WireNumber, f.Decoder, f.Label)

				case protoreflect.Repeated:
					gFP("%s PD.repeated %d %s .%s "+getter,
						prefix, f.WireNumber, f.Decoder, f.Label, f.Label)
				}
			}
		}
		g.P("        ]")
	}

	// Union decoders
	for _, u := range m.Unions {
		g.P(u.DecodeID, " : PD.Decoder ", u.ID)
		g.P(u.DecodeID, " =")
		g.P("    let")
		g.P("        conv v =")
		g.P("            case v of")
		for _, v := range u.Variants {
			g.P("                ", v.Number, " ->")
			g.P("                    ", v.ID)
		}
		g.P("                wire ->")
		g.P("                    ", u.DefaultVariant.ID, " wire")
		g.P("    in")
		g.P("    PD.map conv PD.int32")
	}

	// Record encoders
	for _, r := range m.Records {
		param := "v"
		if len(r.Fields) == 0 {
			param = "_"
		}
		g.P(r.EncodeID, " : ", r.ID, " -> PE.Encoder")
		g.P(r.EncodeID, " ", param, " =")
		if len(r.Oneofs) > 0 {
			g.P("    let")
			for _, o := range r.Oneofs {
				ws := "        "
				gFP("%s%s o =", ws, o.EncodeID)
				gFP("%s    case o of", ws)
				ws += "        "
				for _, v := range o.Variants {
					f := v.Field
					id := v.ID
					if o.IsSynthetic { // No sub-enum
						id = ""
					}
					gFP("%sJust (%s data) ->", ws, id)
					gFP("%s    [ ( %d, %s data ) ]", ws, f.WireNumber, f.Encoder)
				}
				// Nil isn't encoded on the wire
				gFP("%sNothing ->", ws)
				gFP("%s    []", ws)
			}
			g.P("    in")
		}
		g.P("    PE.message <|")
		g.P("        [")
		// Regular (non-oneof) fields
		var written bool
		for _, f := range r.Fields {
			if f.IsOneof { // Skip
				continue
			}
			prefix := "            "
			if written { // Can't do i != 0 because of "continue"
				prefix += ","
			}
			// Special fields?
			if f.IsMap {
				gFP("%s ( %d, PE.dict %s %s v.%s )",
					prefix, f.WireNumber, f.Key.Encoder, f.Encoder, f.Label)
			} else if f.Cardinality == protoreflect.Repeated {
				gFP("%s ( %d, PE.list %s v.%s )",
					prefix, f.WireNumber, f.Encoder, f.Label)
			} else {
				gFP("%s ( %d, %s v.%s )",
					prefix, f.WireNumber, f.Encoder, f.Label)
			}
			written = true
		}
		g.P("        ]")
		if len(r.Oneofs) > 0 {
			// Oneof field handling
			written = false
			for _, f := range r.Fields {
				if !f.IsOneof { // Already handled
					continue
				}
				gFP("        ++ %s v.%s", f.Encoder, f.Label)
			}
		}
	}

	// Union encoders
	for _, u := range m.Unions {
		g.P(u.EncodeID, " : ", u.ID, " -> PE.Encoder")
		g.P(u.EncodeID, " v =")
		g.P("    let")
		g.P("        conv =")
		g.P("            case v of")
		g.P("                ", u.DefaultVariant.ID, " wire ->")
		g.P("                    wire")
		for _, v := range u.Variants {
			g.P("                ", v.ID, " ->")
			g.P("                    ", v.Number)
		}
		g.P("    in")
		g.P("    PE.int32 conv")
	}
}
