package elmgen

import (
	"bytes"
	"fmt"
	"io"
	"os"
	"os/exec"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/reflect/protoreflect"
)

func FormatFile(plugin *protogen.Plugin, path string, file *protogen.GeneratedFile) *protogen.GeneratedFile {
	// Fetch unformatted content
	content, err := file.Content()
	plugin.Error(err)
	unformatted := bytes.NewBuffer(content)
	file.Skip()
	// Run through elm-format
	formatted := plugin.NewGeneratedFile(path, "")
	err = runElmFormat(unformatted, formatted)
	plugin.Error(err)
	return formatted
}

func runElmFormat(in io.Reader, out io.Writer) error {
	cmd := exec.Command("elm-format", "--yes", "--stdin")
	cmd.Stdin = in
	cmd.Stderr = os.Stderr
	cmd.Stdout = out
	return cmd.Run()
}

func GenerateCodec(m *Module, g *protogen.GeneratedFile) {
	gFP := func(formatter string, args ...interface{}) {
		g.P(fmt.Sprintf(formatter, args...))
	}
	g.P("-- Generated by protoc-gen-elmgen. DO NOT EDIT!")
	g.P("module ", m.Name, " exposing (..)")

	g.P("-- This module is broken down into: records (messages), unions (enums), oneofs, empty constructors (zero values), decoders, and encoders")
	var recordIDs, unionIDs, oneofIDs []string
	for _, r := range m.Records {
		recordIDs = append(recordIDs, string(r.ID))
	}
	for _, u := range m.Unions {
		unionIDs = append(unionIDs, string(u.ID))
	}
	for _, o := range m.Oneofs {
		if !o.IsSynthetic {
			oneofIDs = append(oneofIDs, string(o.ID))
		}
	}
	idsToStr := func(ids []string) string {
		if len(ids) == 0 {
			return "(none)"
		}
		return strings.Join(ids, " ")
	}
	g.P("-- Records: ", idsToStr(recordIDs))
	g.P("-- Unions: ", idsToStr(unionIDs))
	g.P("-- Oneofs: ", idsToStr(oneofIDs))

	g.P("import Protobuf.Decode as PD")
	g.P("import Protobuf.Encode as PE")
	if m.Imports.Bytes {
		g.P("import Bytes exposing (Bytes)")
		g.P("import Bytes.Encode as BE")
	}
	if m.Imports.Dict {
		g.P("import Dict exposing (Dict)")
	}

	g.P("-- Records from messages")
	for _, r := range m.Records {
		g.P("type alias ", r.ID, " =")
		g.P("    {")
		for i, f := range r.Fields {
			prefix := ","
			if i == 0 {
				prefix = ""
			}
			g.P("    ", prefix, " ", f.Label, " : ", f.Type)
		}
		g.P("    }")
	}

	g.P("-- Unions from enums")
	for _, u := range m.Unions {
		g.P("type ", u.ID)
		g.P("    = ", u.DefaultVariant.ID, " Int")
		for _, v := range u.Variants {
			g.P("    | ", v.ID)
		}
		for _, a := range u.Aliases {
			g.P(a.Alias, " : ", u.ID)
			g.P(a.Alias, " = ", a.ID)
		}
	}

	g.P("-- Oneofs from messages")
	for _, o := range m.Oneofs {
		// Skip optional
		if o.IsSynthetic {
			continue
		}
		g.P("type ", o.ID)
		for i, v := range o.Variants {
			prefix := "|"
			if i == 0 {
				prefix = "="
			}
			g.P("    ", prefix, " ", v.ID, " ", v.Field.Type)
		}
	}

	g.P("-- Zero (empty) record constructors")
	for _, r := range m.Records {
		g.P(r.ZeroID, " : ", r.ID)
		g.P(r.ZeroID, " =")
		zeros := []interface{}{"    ", r.ID}
		for _, f := range r.Fields {
			zeros = append(zeros, " ", f.Zero)
		}
		g.P(zeros...)
	}

	g.P("-- Zero (empty) union constructors")
	for _, u := range m.Unions {
		g.P(u.ZeroID, " : ", u.ID)
		g.P(u.ZeroID, " =")
		g.P("    ", u.DefaultVariant.ID, " 0")
	}

	g.P("-- Record decoders")
	for _, r := range m.Records {
		g.P(r.DecodeID, " : PD.Decoder ", r.ID)
		g.P(r.DecodeID, " =")
		// Build oneof decoders inline since they're unique to the message
		if len(r.Oneofs) > 0 {
			g.P("    let")
			for _, o := range r.Oneofs {
				g.P("        ", o.DecodeID, " =")
				for j, v := range o.Variants {
					prefix := ","
					if j == 0 {
						prefix = "["
					}
					gFP("                %s ( %d, PD.map %s %s )",
						prefix, v.Field.WireNumber, v.ID, v.Field.Decoder)
				}
				g.P("                ]")
			}
			g.P("    in")
		}
		g.P("    PD.message ", r.ZeroID)
		g.P("        [")
		for i, f := range r.Fields {
			prefix := "            "
			if i != 0 {
				prefix += ","
			}
			// Pick a FieldDecoder
			var decoder string
			if f.IsOneof {
				decoder = "PD.oneOf"
			} else {
				switch f.Cardinality {
				default:
					fallthrough
				case protoreflect.Optional:
					decoder = fmt.Sprintf("PD.optional %d", f.WireNumber)
				case protoreflect.Required:
					decoder = fmt.Sprintf("PD.required %d", f.WireNumber)
				case protoreflect.Repeated:
					decoder = fmt.Sprintf("PD.repeated %d", f.WireNumber)
				}
			}
			// TODO: mapped
			gFP("%s %s %s (\\v m -> { m | %s = v })",
				prefix, decoder, f.Decoder, f.Label)
		}
		g.P("        ]")
	}

	g.P("-- Union decoders")
	for _, u := range m.Unions {
		g.P(u.DecodeID, " : PD.Decoder ", u.ID)
		g.P(u.DecodeID, " =")
		g.P("    let")
		g.P("        conv v =")
		g.P("            case v of")
		for _, v := range u.Variants {
			g.P("                ", v.Number, " ->")
			g.P("                    ", v.ID)
		}
		g.P("                wire ->")
		g.P("                    ", u.DefaultVariant.ID, " wire")
		g.P("    in")
		g.P("    PD.map conv PD.int32")
	}

	g.P("-- Record encoders")
	for _, r := range m.Records {
		param := "v"
		if len(r.Fields) == 0 {
			param = "_"
		}
		g.P(r.EncodeID, " : ", r.ID, " -> PE.Encoder")
		g.P(r.EncodeID, " ", param, " =")
		if len(r.Oneofs) > 0 {
			g.P("    let")
			for _, o := range r.Oneofs {
				ws := "        "
				gFP("%s%s o =", ws, o.EncodeID)
				gFP("%s    case o of", ws)
				ws += "        "
				for _, v := range o.Variants {
					f := v.Field
					gFP("%sJust (%s data) ->", ws, v.ID)
					gFP("%s    [ ( %d, %s data ) ]", ws, f.WireNumber, f.Encoder)
				}
				// Nil isn't encoded on the wire
				gFP("%sNothing ->", ws)
				gFP("%s    []", ws)
			}
			g.P("    in")
		}
		g.P("    PE.message <|")
		g.P("        [")
		// Regular (non-oneof) fields
		var written bool
		for _, f := range r.Fields {
			if f.IsOneof { // Skip
				continue
			}
			prefix := "            "
			if written { // Can't do i != 0 because of "continue"
				prefix += ","
			}
			written = true
			gFP("%s ( %d, %s v.%s )",
				prefix, f.WireNumber, f.Encoder, f.Label)
		}
		g.P("        ]")
		if len(r.Oneofs) > 0 {
			// Oneof field handling
			written = false
			for _, f := range r.Fields {
				if !f.IsOneof { // Already handled
					continue
				}
				gFP("        ++ %s v.%s", f.Encoder, f.Label)
			}
		}
	}

	g.P("-- Union encoders")
	for _, u := range m.Unions {
		g.P(u.EncodeID, " : ", u.ID, " -> PE.Encoder")
		g.P(u.EncodeID, " v =")
		g.P("    let")
		g.P("        conv =")
		g.P("            case v of")
		g.P("                ", u.DefaultVariant.ID, " wire ->")
		g.P("                    wire")
		for _, v := range u.Variants {
			g.P("                ", v.ID, " ->")
			g.P("                    ", v.Number)
		}
		g.P("    in")
		g.P("    PE.int32 conv")
	}
}
