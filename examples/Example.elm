-- Generated by protoc-gen-elmgen. DO NOT EDIT!


module Example exposing (..)

-- This module is broken down into: records (messages), unions (enums), oneofs, empty constructors (zero values), decoders, and encoders
-- Records: AllTogether NestedAbc Scalar
-- Unions: Answer
-- Oneofs: AllTogetherFavourite

import Bytes exposing (Bytes)
import Bytes.Encode as BE
import Dict exposing (Dict)
import Protobuf.Decode as PD
import Protobuf.Encode as PE


type alias AllTogether =
    { myList : List String
    , myMap : Dict String Bool
    , favourite : Maybe AllTogetherFavourite
    , my_name : Maybe String
    , abc : NestedAbc
    , answer : Answer
    }


type alias NestedAbc =
    { a : Int
    , b : Int
    , c : Int
    }


type alias Scalar =
    { myDouble : Float
    , myFloat : Float
    , myInt32 : Int
    , myUint32 : Int
    , mySint32 : Int
    , myFixed32 : Int
    , mySfixed32 : Int
    , myBool : Bool
    , myString : String
    , myBytes : Bytes
    }


type Answer
    = MaybeAnswer Int
    | YesAnswer
    | NoAnswer


type AllTogetherFavourite
    = MyStrFavourite String
    | MyNumFavourite Int
    | SelectionFavourite Scalar


emptyAllTogether : AllTogether
emptyAllTogether =
    AllTogether [] Dict.empty Nothing Nothing emptyNestedAbc emptyAnswer


emptyNestedAbc : NestedAbc
emptyNestedAbc =
    NestedAbc 0 0 0


emptyScalar : Scalar
emptyScalar =
    Scalar 0 0 0 0 0 0 0 False "" (BE.encode (BE.sequence []))


emptyAnswer : Answer
emptyAnswer =
    MaybeAnswer 0


allTogetherDecoder : PD.Decoder AllTogether
allTogetherDecoder =
    let
        allTogetherFavouriteDecoder =
            [ ( 3, PD.map MyStrFavourite PD.string )
            , ( 4, PD.map MyNumFavourite PD.int32 )
            , ( 5, PD.map SelectionFavourite scalarDecoder )
            ]

        exampleAllTogetherMyNameDecoder =
            [ ( 6, PD.string )
            ]
    in
    PD.message emptyAllTogether
        [ PD.repeated 1 PD.string .myList (\v m -> { m | myList = v })
        , PD.mapped 2 ( "", False ) PD.string PD.bool .myMap (\v m -> { m | myMap = v })
        , PD.oneOf allTogetherFavouriteDecoder (\v m -> { m | favourite = v })
        , PD.oneOf exampleAllTogetherMyNameDecoder (\v m -> { m | my_name = v })
        , PD.optional 7 nestedAbcDecoder (\v m -> { m | abc = v })
        , PD.optional 8 answerDecoder (\v m -> { m | answer = v })
        ]


nestedAbcDecoder : PD.Decoder NestedAbc
nestedAbcDecoder =
    PD.message emptyNestedAbc
        [ PD.optional 1 PD.int32 (\v m -> { m | a = v })
        , PD.optional 2 PD.int32 (\v m -> { m | b = v })
        , PD.optional 3 PD.int32 (\v m -> { m | c = v })
        ]


scalarDecoder : PD.Decoder Scalar
scalarDecoder =
    PD.message emptyScalar
        [ PD.optional 1 PD.double (\v m -> { m | myDouble = v })
        , PD.optional 2 PD.float (\v m -> { m | myFloat = v })
        , PD.optional 3 PD.int32 (\v m -> { m | myInt32 = v })
        , PD.optional 5 PD.uint32 (\v m -> { m | myUint32 = v })
        , PD.optional 7 PD.sint32 (\v m -> { m | mySint32 = v })
        , PD.optional 9 PD.fixed32 (\v m -> { m | myFixed32 = v })
        , PD.optional 11 PD.sfixed32 (\v m -> { m | mySfixed32 = v })
        , PD.optional 13 PD.bool (\v m -> { m | myBool = v })
        , PD.optional 14 PD.string (\v m -> { m | myString = v })
        , PD.optional 15 PD.bytes (\v m -> { m | myBytes = v })
        ]


answerDecoder : PD.Decoder Answer
answerDecoder =
    let
        conv v =
            case v of
                1 ->
                    YesAnswer

                2 ->
                    NoAnswer

                wire ->
                    MaybeAnswer wire
    in
    PD.map conv PD.int32


allTogetherEncoder : AllTogether -> PE.Encoder
allTogetherEncoder v =
    let
        allTogetherFavouriteEncoder o =
            case o of
                Just (MyStrFavourite data) ->
                    [ ( 3, PE.string data ) ]

                Just (MyNumFavourite data) ->
                    [ ( 4, PE.int32 data ) ]

                Just (SelectionFavourite data) ->
                    [ ( 5, scalarEncoder data ) ]

                Nothing ->
                    []

        exampleAllTogetherMyNameEncoder o =
            case o of
                Just data ->
                    [ ( 6, PE.string data ) ]

                Nothing ->
                    []
    in
    PE.message <|
        [ ( 1, PE.list PE.string v.myList )
        , ( 2, PE.dict PE.string PE.bool v.myMap )
        , ( 7, nestedAbcEncoder v.abc )
        , ( 8, answerEncoder v.answer )
        ]
            ++ allTogetherFavouriteEncoder v.favourite
            ++ exampleAllTogetherMyNameEncoder v.my_name


nestedAbcEncoder : NestedAbc -> PE.Encoder
nestedAbcEncoder v =
    PE.message <|
        [ ( 1, PE.int32 v.a )
        , ( 2, PE.int32 v.b )
        , ( 3, PE.int32 v.c )
        ]


scalarEncoder : Scalar -> PE.Encoder
scalarEncoder v =
    PE.message <|
        [ ( 1, PE.double v.myDouble )
        , ( 2, PE.float v.myFloat )
        , ( 3, PE.int32 v.myInt32 )
        , ( 5, PE.uint32 v.myUint32 )
        , ( 7, PE.sint32 v.mySint32 )
        , ( 9, PE.fixed32 v.myFixed32 )
        , ( 11, PE.sfixed32 v.mySfixed32 )
        , ( 13, PE.bool v.myBool )
        , ( 14, PE.string v.myString )
        , ( 15, PE.bytes v.myBytes )
        ]


answerEncoder : Answer -> PE.Encoder
answerEncoder v =
    let
        conv =
            case v of
                MaybeAnswer wire ->
                    wire

                YesAnswer ->
                    1

                NoAnswer ->
                    2
    in
    PE.int32 conv
