-- Generated by protoc-gen-elmgen. DO NOT EDIT!


module ExampleTests exposing (..)

import Bytes exposing (Bytes)
import Bytes.Encode as BE
import Dict
import Example as Codec
import Expect
import Fuzz exposing (Fuzzer)
import Protobuf.Decode as PD
import Protobuf.Encode as PE
import Test exposing (Test, fuzz, test)


fuzzInt32 : Fuzzer Int
fuzzInt32 =
    Fuzz.intRange -2147483648 2147483647


fuzzUint32 : Fuzzer Int
fuzzUint32 =
    Fuzz.intRange 0 4294967295


fuzzFloat32 : Fuzzer Float
fuzzFloat32 =
    Fuzz.map (\i -> 2 ^ toFloat i) fuzzInt32


fuzzBytes : Fuzzer Bytes
fuzzBytes =
    Fuzz.intRange 0 255
        |> Fuzz.map BE.unsignedInt8
        |> Fuzz.list
        |> Fuzz.map (BE.sequence >> BE.encode)


answerFuzzer : Fuzzer Codec.Answer
answerFuzzer =
    Fuzz.oneOf
        [ Fuzz.map Codec.Maybe_Answer fuzzInt32
        , Fuzz.constant Codec.Yes_Answer
        , Fuzz.constant Codec.No_Answer
        ]


allTogetherFuzzer : Fuzzer Codec.AllTogether
allTogetherFuzzer =
    let
        allTogether_FavouriteFuzzer =
            Fuzz.oneOf
                [ Fuzz.map Codec.MyStr_Favourite Fuzz.string
                , Fuzz.map Codec.MyNum_Favourite fuzzInt32
                , Fuzz.map Codec.Selection_Favourite scalarFuzzer
                ]

        example_AllTogether_MyNameFuzzer =
            Fuzz.oneOf
                [ Fuzz.string
                ]
    in
    Fuzz.map Codec.AllTogether
        (Fuzz.list Fuzz.string)
        |> Fuzz.andMap
            (Fuzz.map Dict.fromList
                (Fuzz.list (Fuzz.tuple ( Fuzz.string, Fuzz.bool )))
            )
        |> Fuzz.andMap (Fuzz.maybe allTogether_FavouriteFuzzer)
        |> Fuzz.andMap (Fuzz.maybe example_AllTogether_MyNameFuzzer)
        |> Fuzz.andMap nestedAbcFuzzer
        |> Fuzz.andMap answerFuzzer


nestedAbcFuzzer : Fuzzer Codec.NestedAbc
nestedAbcFuzzer =
    Fuzz.map Codec.NestedAbc
        fuzzInt32
        |> Fuzz.andMap fuzzInt32
        |> Fuzz.andMap fuzzInt32


scalarFuzzer : Fuzzer Codec.Scalar
scalarFuzzer =
    Fuzz.map Codec.Scalar
        Fuzz.float
        |> Fuzz.andMap fuzzFloat32
        |> Fuzz.andMap fuzzInt32
        |> Fuzz.andMap fuzzUint32
        |> Fuzz.andMap fuzzInt32
        |> Fuzz.andMap fuzzUint32
        |> Fuzz.andMap fuzzInt32
        |> Fuzz.andMap Fuzz.bool
        |> Fuzz.andMap Fuzz.string
        |> Fuzz.andMap fuzzBytes


testAllTogether : Test
testAllTogether =
    let
        run data =
            PE.encode (Codec.allTogetherEncoder data)
                |> PD.decode Codec.allTogetherDecoder
                |> Expect.equal (Just data)
    in
    Test.describe "encode then decode AllTogether"
        [ test "empty" (\_ -> run Codec.emptyAllTogether)
        , fuzz allTogetherFuzzer "fuzzer" run
        ]


testNestedAbc : Test
testNestedAbc =
    let
        run data =
            PE.encode (Codec.nestedAbcEncoder data)
                |> PD.decode Codec.nestedAbcDecoder
                |> Expect.equal (Just data)
    in
    Test.describe "encode then decode NestedAbc"
        [ test "empty" (\_ -> run Codec.emptyNestedAbc)
        , fuzz nestedAbcFuzzer "fuzzer" run
        ]


testScalar : Test
testScalar =
    let
        run data =
            PE.encode (Codec.scalarEncoder data)
                |> PD.decode Codec.scalarDecoder
                |> Expect.equal (Just data)
    in
    Test.describe "encode then decode Scalar"
        [ test "empty" (\_ -> run Codec.emptyScalar)
        , fuzz scalarFuzzer "fuzzer" run
        ]


testAnswer : Test
testAnswer =
    let
        run data =
            PE.encode (Codec.answerEncoder data)
                |> PD.decode Codec.answerDecoder
                |> Expect.equal (Just data)
    in
    Test.describe "encode then decode Answer"
        [ test "empty" (\_ -> run Codec.emptyAnswer)
        , fuzz answerFuzzer "fuzzer" run
        ]
